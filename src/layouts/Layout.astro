---
import "../styles/global.css";
import Nav from "../components/Nav.astro";
import { languages, hreflangMap, htmlLangMap, normalizeLang, type Lang } from "../i18n";

interface Props {
  title?: string;
  lang?: Lang | string;
  alternates?: Record<string, string>;
}

const props = Astro.props as Props;
const title = props.title ?? "Xiaosi Huang · Portfolio";
const lang: Lang = normalizeLang(props.lang as string);

// strip leading /{lang}
const raw = Astro.url.pathname || "/";
const langPattern = new RegExp(`^/(?:${languages.join("|")})(?=/|$)`);
const logicalPath = raw.replace(langPattern, "");

// hreflang URLs
const urlFor = (code: string) =>
  new URL(`${`/${code}`}${logicalPath || "/"}`, Astro.url.origin).toString();

const htmlLang = htmlLangMap[lang];
---
<!doctype html>
<html lang={htmlLang} class="scroll-smooth">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
    <meta name="color-scheme" content="light dark" />
    <meta name="theme-color" content="#ffffff" media="(prefers-color-scheme: light)" />
    <meta name="theme-color" content="#0b0f15" media="(prefers-color-scheme: dark)" />

    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700;800&display=swap" rel="stylesheet" />

    <!-- KaTeX CSS for LaTeX rendering -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.11/dist/katex.min.css" />

    <title>{title}</title>

    <link rel="canonical" href={Astro.url.origin + Astro.url.pathname} />
    <meta name="description" content="Tableau visualization, dashboard design, and business analytics. Selected projects, methods, and notes." />
    <meta property="og:title" content={title} />
    <meta property="og:description" content="Portfolio of visualization & analytics work." />
    <meta property="og:type" content="website" />
    <meta property="og:url" content={Astro.url.origin + Astro.url.pathname} />
    <meta property="og:image" content="/og-cover.png" />
    <meta name="twitter:card" content="summary_large_image" />

    <link rel="icon" href="/favicon.svg?v=3" type="image/svg+xml" />
    <link rel="mask-icon" href="/favicon.svg?v=3" color="#2563eb" />

    {/* hreflang */}
    {languages.map((code) => (
      <link rel="alternate" hreflang={hreflangMap[code]} href={urlFor(code)} />
    ))}
    <link rel="alternate" hreflang="x-default" href={urlFor("en")} />
  </head>

  <body>
    <Nav lang={lang} alternates={props.alternates ?? {}} />
    <main class="mx-auto max-w-7xl px-4 md:px-8 py-12">
      <slot />
    </main>

    <!-- ✅ 语言切换后的滚动恢复（hash > 像素 > 比例）。等待高度稳定 + 重试机制 + 顶部导航偏移 -->
    <script is:inline>
      (function restoreAfterLangSwitch() {
        try {
          if ('scrollRestoration' in history) history.scrollRestoration = 'manual';

          const raw = sessionStorage.getItem('__langScroll__');
          if (!raw) return;
          const saved = JSON.parse(raw);
          // 30s 过期
          if (!saved || Date.now() - (saved.ts || 0) > 30000) {
            sessionStorage.removeItem('__langScroll__');
            return;
          }

          const targetHash = location.hash || saved.hash || '';

          // 估算顶部粘性导航高度，恢复时做减法，避免被顶栏盖住
          function headerOffset() {
            const header = document.querySelector('header');
            const h = header ? header.getBoundingClientRect().height : 0;
            return Math.min(Math.max(h, 0), 120); // clamp 到 0~120
          }

          function pxScroll(y) {
            const doc = document.documentElement, body = document.body;
            const max = (doc.scrollHeight || body.scrollHeight || 0) - window.innerHeight;
            const top = Math.max(0, Math.min(max, y - headerOffset()));
            window.scrollTo({ top, behavior: 'auto' });
          }

          function ratioScroll(r) {
            const doc = document.documentElement, body = document.body;
            const max = (doc.scrollHeight || body.scrollHeight || 0) - window.innerHeight;
            const top = Math.max(0, Math.min(max, Math.round(max * r) - headerOffset()));
            window.scrollTo({ top, behavior: 'auto' });
          }

          function hashScroll() {
            if (!targetHash) return false;
            const id = targetHash.slice(1);
            const el = id ? document.getElementById(id) : null;
            if (!el) return false;
            const y = el.getBoundingClientRect().top + window.scrollY - headerOffset();
            window.scrollTo({ top: Math.max(0, y), behavior: 'auto' });
            return true;
          }

          // 等页面高度稳定：连续多次相同 scrollHeight 或到达最大等待
          function waitForStableHeight(timeoutMs = 3000, stableTimes = 3, interval = 120) {
            return new Promise((resolve) => {
              let last = 0, same = 0;
              const start = Date.now();
              const timer = setInterval(() => {
                const h = document.documentElement.scrollHeight;
                if (h === last) same++; else same = 0;
                last = h;

                if (same >= stableTimes || Date.now() - start > timeoutMs) {
                  clearInterval(timer);
                  resolve(void 0);
                }
              }, interval);
            });
          }

          // 执行恢复，有重试（例如图片后续加载改变高度）
          async function doRestore() {
            await waitForStableHeight();

            // 1) hash 优先
            if (hashScroll()) return done();

            // 2) 像素更精确
            if (Number.isFinite(saved.y)) {
              pxScroll(saved.y);
            } else if (Number.isFinite(saved.ratio)) {
              // 3) 比例兜底
              ratioScroll(saved.ratio);
            }

            // 如果仍然在顶部而目标位置大于 200px，重试几次
            let tries = 6;
            const retry = () => {
              const wantTop = Number.isFinite(saved.y) ? saved.y : (document.documentElement.scrollHeight - window.innerHeight) * (saved.ratio || 0);
              if (window.scrollY < 10 && wantTop > 200 && tries-- > 0) {
                // 再等一小会（比如图片/KaTeX继续撑高）
                setTimeout(() => {
                  // 优先再试 hash（若该语言的 id 晚于首次出现）
                  if (!hashScroll()) {
                    if (Number.isFinite(saved.y)) pxScroll(saved.y);
                    else if (Number.isFinite(saved.ratio)) ratioScroll(saved.ratio);
                  }
                  retry();
                }, 160);
              } else {
                done();
              }
            };
            retry();
          }

          const done = () => { try { sessionStorage.removeItem('__langScroll__'); } catch {} };

          // 等到 load + 字体 ready，再两帧后恢复
          const twoRAF = () => requestAnimationFrame(() => requestAnimationFrame(doRestore));
          if (document.readyState === 'complete') {
            (document as any).fonts?.ready?.then(twoRAF).catch(twoRAF);
          } else {
            window.addEventListener('load', () => {
              (document as any).fonts?.ready?.then(twoRAF).catch(twoRAF);
            }, { once: true });
          }
        } catch (err) {
          // console.debug('[lang-switch] restore error', err);
        }
      })();
    </script>

    <footer style="border-top:1px solid var(--border)" class="py-10">
      <div class="mx-auto max-w-7xl px-4 md:px-8 text-sm" style="opacity:.7">
        © {new Date().getFullYear()} Xiaosi Huang. All rights reserved.
      </div>
    </footer>
  </body>
</html>
